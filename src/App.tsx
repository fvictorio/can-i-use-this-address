import React, { useEffect, useState } from "react";
import { useWeb3Context } from "web3-react";
import { Contract, Wallet, utils } from "ethers";
import "./App.css";

const contractAbi = [
  "function unsafeAddresses(address) view returns (bool)",
  "function add(uint8 v, bytes32 r, bytes32 s) public",
  "function addMultiple(uint8[] vs, bytes32[] rs, bytes32[] ss) public"
];
const contractAddress = "0xa334b942d69f4d2cc6806010984dc19637ebb47f";

const generateSig = async (privateKey: string) => {
  const wallet = new Wallet(privateKey);
  const payload = utils.defaultAbiCoder.encode(["string"], ["This address is unsafe"]);
  const payloadHash = utils.keccak256(payload);
  const signature = await wallet.signMessage(utils.arrayify(payloadHash));
  const sig = utils.splitSignature(signature);
  return sig;
};

const addPrivateKey = async (privateKey: string, signer: any) => {
  let sig = await generateSig(privateKey);
  const contract = new Contract(contractAddress, contractAbi, signer);
  await contract.add(sig.v, sig.r, sig.s);
};

const addMnemonic = async (mnemonic: string, signer: any) => {
  let vs = [],
    rs = [],
    ss = [];
  for (let i = 0; i < 10; i++) {
    const privateKey = Wallet.fromMnemonic(mnemonic, `m/44'/60'/0'/0/${i}`).privateKey;
    const sig = await generateSig(privateKey);
    vs.push(sig.v);
    rs.push(sig.r);
    ss.push(sig.s);
  }
  const contract = new Contract(contractAddress, contractAbi, signer);
  await contract.addMultiple(vs, rs, ss);
};

function App() {
  const context = useWeb3Context();
  const [inputAddress, setInputAddress] = useState("");
  const [inputPK, setInputPK] = useState("");
  const [inputMnemonic, setInputMnemonic] = useState("");
  const [address, setAddress] = useState("");
  const [isUnsafe, setIsUnsafe] = useState<boolean | null>(null);

  useEffect(() => {
    if (!context.active) {
      context.setFirstValidConnector(["MetaMask"]);
    }
  }, [context]);

  const check = (addressToCheck: string) => {
    setAddress(addressToCheck);
    setInputAddress("");
    const contract = new Contract(contractAddress, contractAbi, context.library);

    contract.unsafeAddresses(addressToCheck).then(setIsUnsafe);
  };

  const addInputPK = async (privateKey: string) => {
    await addPrivateKey(privateKey, await context.library.getSigner());
    setInputPK("");
  };

  const addInputMnemonic = async (mnemonic: string) => {
    await addMnemonic(mnemonic, await context.library.getSigner());
    setInputMnemonic("");
  };

  if (!context.active) {
    return <div>Loading...</div>;
  }

  return (
    <div className="App">
      <input placeholder="Address" value={inputAddress} onChange={e => setInputAddress(e.currentTarget.value)} />
      <button disabled={!inputAddress} onClick={() => check(inputAddress)}>
        Check
      </button>
      {isUnsafe !== null ? (
        <div style={{ color: isUnsafe ? "red" : "green" }}>
          {" "}
          Address {address} is {isUnsafe ? "not safe" : "safe"}
        </div>
      ) : (
        <div>&nbsp;</div>
      )}
      <br />
      <br />
      <input placeholder="Private key" value={inputPK} onChange={e => setInputPK(e.currentTarget.value)} />
      <button disabled={!inputPK} onClick={() => addInputPK(inputPK)}>
        Add private key
      </button>
      <br />
      <br />
      <input placeholder="Mnemonic" value={inputMnemonic} onChange={e => setInputMnemonic(e.currentTarget.value)} />
      <button disabled={!inputMnemonic} onClick={() => addInputMnemonic(inputMnemonic)}>
        Add mnemonic
      </button>
      <br />
      <br />
      <p>
        Check if some ethereum address is compromised. Examples of compromised addresses are addresses generated by{" "}
        <span style={{ fontFamily: "monospace" }}>ganache-cli -d</span>, addresses whose private keys have been
        committed to a public repository, or addresses generated by mnemonics that have been committed to a public
        repository.
      </p>

      <p>
        It goes without saying: this list is not exhaustive. An address marked as "safe" could still be compromised. But
        you can be pretty sure that an address marked as not safe shouldn't be used in mainnet.
      </p>
    </div>
  );
}

export default App;
